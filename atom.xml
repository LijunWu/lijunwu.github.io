<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Amy's Blog]]></title>
  <link href="http://lijunwu.github.io/atom.xml" rel="self"/>
  <link href="http://lijunwu.github.io/"/>
  <updated>2017-02-14T19:49:37+08:00</updated>
  <id>http://lijunwu.github.io/</id>
  <author>
    <name><![CDATA[吴丽君]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UICollectionView在特殊场景使用中遇到的问题]]></title>
    <link href="http://lijunwu.github.io/blog/2016/07/29/uicollectionviewde-jian-dan-shi-yong/"/>
    <updated>2016-07-29T13:48:51+08:00</updated>
    <id>http://lijunwu.github.io/blog/2016/07/29/uicollectionviewde-jian-dan-shi-yong</id>
    <content type="html"><![CDATA[<h3>UICollectionView概述</h3>

<p>UICollectionView是iOS6中提供的一种新的数据展示方式。与Table View一样，Collection View的设计中也有Data Source和Delegate，Data Source负责内容部分，Delegate负责交互部分。除此之外，Collection View还增加了一个Layout，通过提供不同的Layout，Collection View可以展示出不同的视图排列。</p>

<p>实现一个Collection View需要用到多个类及协议，把它们按角色分类如下：</p>

<p><img class="center" src="http://lijunwu.github.io/images/2016-07-29-UICollectionView/01.jpg" width="800"></p>

<h4>Top-level containment and management</h4>

<p>UICollectionView充当了一个管理中枢的角色，它通过Data Source获取内容，通过Layout获取布局信息，然后计算每个view的大小、位置等信息，最终将View呈现出来。</p>

<h4>Content management</h4>

<p>Collection View中的内容主要由Data Source提供，Delegate负责的是与交互相关的部分；</p>

<p>Data Source必须提供几个基本数据信息：</p>

<ul>
<li>collection view包含几个section；</li>
<li>每个section中包含几个item；</li>
<li>对于一个给定的section或item，用哪个视图来展示相应的内容；</li>
</ul>


<p>由Data Source提供的视图包括Cells和Supplementary View（追加视图），这两者都是数据驱动的，并且它们都是Reusable View的子类。     Data Source通过dequeueReusableCellWithReuseIdentifier或dequeueReusableSupplementaryViewOfKind方法向Collection View获取一个view的实例，填充好数据，再返回给Collection View。</p>

<h4>Presentation</h4>

<p>Collection View中展示的view都是可重用的，这种设计与Table View是一致的。所有的可重用视图均继承UICollectionReusableView类，     Collection View中主要有三类可重用视图：</p>

<ul>
<li><p>Cells</p>

<p>  用于展示主要内容；UIKit提供了UICollectionViewCell类，有选中和高亮状态属性。</p></li>
<li><p>SupplementaryView</p>

<p>  用于展示section的一些信息，非必须的。同Cell一样，它也是数据驱动的。</p></li>
<li><p>Decoration views</p>

<p>  装饰视图，主要用来做section的背景，非必须的。它仅仅是视图相关的，不与任何数据绑定，由Layout对象管理；</p></li>
</ul>


<p>前面说到，Data Source可以通过dequeueReusableXXX的方法向Collection View获取一个cell或supplementary view的实例，但在这之前，你必须已经向Collection View注册过这两种视图，注册的方法有两种：registerNib或registerClass，具体方法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 注册cell</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">registerClass:</span><span class="p">(</span><span class="n">nullable</span> <span class="kt">Class</span><span class="p">)</span><span class="nv">cellClass</span> <span class="nf">forCellWithReuseIdentifier:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">identifier</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">registerNib:</span><span class="p">(</span><span class="n">nullable</span> <span class="bp">UINib</span> <span class="o">*</span><span class="p">)</span><span class="nv">nib</span> <span class="nf">forCellWithReuseIdentifier:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">identifier</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 注册supplementary view</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">registerClass:</span><span class="p">(</span><span class="n">nullable</span> <span class="kt">Class</span><span class="p">)</span><span class="nv">viewClass</span> <span class="nf">forSupplementaryViewOfKind:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">elementKind</span> <span class="nf">withReuseIdentifier:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">identifier</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">registerNib:</span><span class="p">(</span><span class="n">nullable</span> <span class="bp">UINib</span> <span class="o">*</span><span class="p">)</span><span class="nv">nib</span> <span class="nf">forSupplementaryViewOfKind:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">kind</span> <span class="nf">withReuseIdentifier:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">identifier</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于Decoration View，由于它是数据无关的，只是视图相关的，所以它是由Layout对象管理，它的注册过程也是在Layout类中完成的。在UICollectionViewLayout类中提供了注册Decoration View的方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">registerClass:</span><span class="p">(</span><span class="n">nullable</span> <span class="kt">Class</span><span class="p">)</span><span class="nv">viewClass</span> <span class="nf">forDecorationViewOfKind:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">elementKind</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">registerNib:</span><span class="p">(</span><span class="n">nullable</span> <span class="bp">UINib</span> <span class="o">*</span><span class="p">)</span><span class="nv">nib</span> <span class="nf">forDecorationViewOfKind:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">elementKind</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Layout</h4>

<p>这是Collection View与Table View最大的不同。尽管Data Source已经提供了View（cell和supplementary view）以及view的内容，但每个view的位置及最终展示形式都是由Layout决定的。Collection View在布局时，会向Layout请求布局信息和view的外观信息，Layout提供了一个UICollectionViewLayoutAttributes类来封装这些信息，包括view的大小、位置以及其他一些与外观展示有关的属性。每个view都会对应一个UICollectionViewLayoutAttributes对象，所以Layout实际上是包含了一个UICollectionViewLayoutAttributes列表。</p>

<ul>
<li><p>Flow Layout</p>

<p>  iOS6，UIKit中为我们提供了一种常用的布局：Flow Layout，它继承基本布局类UICollectionViewLayout。它是 line-based breaking 布局，（items排成一行直到行满，再继续往下一行上去排，直到所有items都排列完成）。通过实现Flow Layout的一些代理方法，可以指定每个item的大小、item之间的距离、行与行之间的距离等等。另外，在Flow Layout中，系统提供了两种类型的supplementary view，分别为header（UICollectionElementKindSectionHeader）和footer（UICollectionElementKindSectionFooter）.</p></li>
<li><p>Transition Layou</p>

<p>  iOS7，UIKit又增加了一种布局类型：Transition Layout，转场布局。一般我们直接setCollectionViewLayout：时也会触发一个从原有Layout到新的Layout的过度动画，但是通过Transition Layout，我们可以对动画过程加一些控制或交互。</p></li>
</ul>


<h3>UICollectionView的使用</h3>

<p>我们项目中有一个小需求，大概是下面这个样子：</p>

<p> <img class="center" src="http://lijunwu.github.io/images/2016-07-29-UICollectionView/02.png" width="222"></p>

<p>从视觉上来看，有多个section，每个section包含多个item，而所有item又是网格排列的，所以UICollectionView应该是比较合适的，布局的话可以用系统提供的Flow Layout，满足我们网格排列的需求，而且它刚好也提供了Section Header View，这样我们就不用自己去创建一个UICollectionViewLayout的子类了；</p>

<p>再从交互上看，要求collection view多选，但是每个section里限制只能选中一个，UICollectionView没有提供相应的API，所以这里我们需要做些额外的工作来控制每个Section里的选中情况。</p>

<ul>
<li>首先创建一个UICollectionView的实例，指定Data Source和Delegate。K12StorePickerCell用来展示每个item的内容，K12StorePickHeaderView用来展示每个section的header，将这两个view注册Collection View。布局方式用系统提供的Flow Layout。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="nb">self</span><span class="p">.</span><span class="n">pickerCV</span><span class="p">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="nb">self</span><span class="p">.</span><span class="n">pickerCV</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="nb">self</span><span class="p">.</span><span class="n">pickerCV</span><span class="p">.</span><span class="n">allowsMultipleSelection</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'><span class="nb">self</span><span class="p">.</span><span class="n">pickerCV</span><span class="p">.</span><span class="n">collectionViewLayout</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UICollectionViewLayout</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">pickerCV</span> <span class="nl">registerNib</span><span class="p">:[</span><span class="n">K12StorePickerCell</span> <span class="n">nib</span><span class="p">]</span> <span class="nl">forCellWithReuseIdentifier</span><span class="p">:</span><span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">K12StorePickerCell</span> <span class="k">class</span><span class="p">])];</span>
</span><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">pickerCV</span> <span class="nl">registerNib</span><span class="p">:[</span><span class="n">K12StorePickHeaderView</span> <span class="n">nib</span><span class="p">]</span> <span class="nl">forSupplementaryViewOfKind</span><span class="p">:</span><span class="n">UICollectionElementKindSectionHeader</span> <span class="nl">withReuseIdentifier</span><span class="p">:</span><span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">K12StorePickHeaderView</span> <span class="k">class</span><span class="p">])];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>实现Data Source</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="nf">collectionView:</span><span class="p">(</span><span class="bp">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span> <span class="nf">numberOfItemsInSection:</span><span class="p">(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="nv">section</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="bp">NSInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// 返回每个section中包含的item的个数</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">UICollectionViewCell</span> <span class="o">*</span><span class="p">)</span><span class="nf">collectionView:</span><span class="p">(</span><span class="bp">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span> <span class="nf">cellForItemAtIndexPath:</span><span class="p">(</span><span class="bp">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">K12StorePickerCell</span> <span class="o">*</span><span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">collectionView</span> <span class="nl">dequeueReusableCellWithReuseIdentifier</span><span class="p">:</span><span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">K12StorePickerCell</span> <span class="k">class</span><span class="p">])</span> <span class="nl">forIndexPath</span><span class="p">:</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// 填充每个cell的内容；</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">cell</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">UICollectionReusableView</span> <span class="o">*</span><span class="p">)</span><span class="nf">collectionView:</span><span class="p">(</span><span class="bp">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span> <span class="nf">viewForSupplementaryElementOfKind:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">kind</span> <span class="nf">atIndexPath:</span><span class="p">(</span><span class="bp">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// UICollectionElementKindSectionHeader是在Flow Layout中定义的一种Supplementary View；</span>
</span><span class='line'>    <span class="n">K12StorePickHeaderView</span> <span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="p">[</span><span class="n">collectionView</span> <span class="nl">dequeueReusableSupplementaryViewOfKind</span><span class="p">:</span><span class="n">UICollectionElementKindSectionHeader</span> <span class="nl">withReuseIdentifier</span><span class="p">:</span><span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">K12StorePickHeaderView</span> <span class="k">class</span><span class="p">])</span> <span class="nl">forIndexPath</span><span class="p">:</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// 填充每个header的内容；</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">header</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="nf">numberOfSectionsInCollectionView:</span><span class="p">(</span><span class="bp">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>实现Delegate</li>
</ul>


<p>我们的需求是每个section种有且只能有一个item被选中，所以我们会将每个section中被选中的item对应的indexPath记下来。当用户选择了一个新的item时，会触发didSelectItemAtIndexPath：方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">collectionView:</span><span class="p">(</span><span class="bp">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span> <span class="nf">didSelectItemAtIndexPath:</span><span class="p">(</span><span class="bp">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 先将同一个section中已被选中的对象deselected；</span>
</span><span class='line'>    <span class="p">[</span><span class="n">collectionView</span> <span class="nl">deselectItemAtIndexPath</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">selectedIndexPath</span> <span class="nl">animated</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// 再将当前的indexPath标记成选中</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">selectedIndexPath</span> <span class="o">=</span> <span class="n">indexPath</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当用户点击一个已经选中的item时，会触发shouldDeselectItemAtIndexPath方法，我们的需求中每个section中至少且只有一个被选中的item，所以这个方法应当返回NO；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">collectionView:</span><span class="p">(</span><span class="bp">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span> <span class="nf">shouldDeselectItemAtIndexPath:</span><span class="p">(</span><span class="bp">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>实现Flow Layout的Delegate</li>
</ul>


<p>Flow Layout为用户提供了几个方法用来设置item大小、行间距、item间距等信息；在这里我们主要实现了下面几个方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 提供每个item的尺寸大小</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">CGSize</span><span class="p">)</span><span class="nf">collectionView:</span><span class="p">(</span><span class="bp">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span> <span class="nf">layout:</span><span class="p">(</span><span class="bp">UICollectionViewLayout</span><span class="o">*</span><span class="p">)</span><span class="nv">collectionViewLayout</span> <span class="nf">sizeForItemAtIndexPath:</span><span class="p">(</span><span class="bp">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 设置section的内边距（不影响header和footer）</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">UIEdgeInsets</span><span class="p">)</span><span class="nf">collectionView:</span><span class="p">(</span><span class="bp">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span> <span class="nf">layout:</span><span class="p">(</span><span class="bp">UICollectionViewLayout</span><span class="o">*</span><span class="p">)</span><span class="nv">collectionViewLayout</span> <span class="nf">insetForSectionAtIndex:</span><span class="p">(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="nv">section</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 最小的行间距</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nf">collectionView:</span><span class="p">(</span><span class="bp">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span> <span class="nf">layout:</span><span class="p">(</span><span class="bp">UICollectionViewLayout</span><span class="o">*</span><span class="p">)</span><span class="nv">collectionViewLayout</span> <span class="nf">minimumLineSpacingForSectionAtIndex:</span><span class="p">(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="nv">section</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 处于同一行的item之间的最小距离</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nf">collectionView:</span><span class="p">(</span><span class="bp">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span> <span class="nf">layout:</span><span class="p">(</span><span class="bp">UICollectionViewLayout</span><span class="o">*</span><span class="p">)</span><span class="nv">collectionViewLayout</span> <span class="nf">minimumInteritemSpacingForSectionAtIndex:</span><span class="p">(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="nv">section</span><span class="p">;</span>
</span><span class='line'><span class="c1">// Header的尺寸</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">CGSize</span><span class="p">)</span><span class="nf">collectionView:</span><span class="p">(</span><span class="bp">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span> <span class="nf">layout:</span><span class="p">(</span><span class="bp">UICollectionViewLayout</span><span class="o">*</span><span class="p">)</span><span class="nv">collectionViewLayout</span> <span class="nf">referenceSizeForHeaderInSection:</span><span class="p">(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="nv">section</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>至此，一个基本的Collection View搭配Flow Layout的使用就完成了，撒花。</p>

<p>但是后来，我们遇到了一些特殊情况。</p>

<p><img class="center" src="http://lijunwu.github.io/images/2016-07-29-UICollectionView/03.png" width="400"></p>

<p>如果限制了item的默认大小，当某个item的内容过长时，就会显示不下。所以后来我拿到了这样的视觉稿：内容超过item默认大小的，就按实际大小展示。</p>

<p><img class="center" src="http://lijunwu.github.io/images/2016-07-29-UICollectionView/04.png" width="400"></p>

<p>修改完代码后，新的问题出现了。程序运行的效果是这样的：</p>

<p><img class="center" src="http://lijunwu.github.io/images/2016-07-29-UICollectionView/05.png" width="400"></p>

<p>这里补充说下Flow Layout的布局方式：按一条直线路径去排列item，当一行没有足够的空间去放置下一个item时，就切换到下一行，然后继续排列剩下的item。如下图。</p>

<p><img class="center" src="http://lijunwu.github.io/images/2016-07-29-UICollectionView/06.png" width="578"></p>

<p>还记得我们在Flow Layout的delegate中实现的两个关于item间距及行间距的方法吗？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nf">collectionView:</span><span class="p">(</span><span class="bp">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span> <span class="nf">layout:</span><span class="p">(</span><span class="bp">UICollectionViewLayout</span><span class="o">*</span><span class="p">)</span><span class="nv">collectionViewLayout</span> <span class="nf">minimumLineSpacingForSectionAtIndex:</span><span class="p">(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="nv">section</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nf">collectionView:</span><span class="p">(</span><span class="bp">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span> <span class="nf">layout:</span><span class="p">(</span><span class="bp">UICollectionViewLayout</span><span class="o">*</span><span class="p">)</span><span class="nv">collectionViewLayout</span> <span class="nf">minimumInteritemSpacingForSectionAtIndex:</span><span class="p">(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="nv">section</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里我们指定的是最小距离，实际情况是，Layout有可能增大item之间的间距。
当item的大小不固定时，如果某一行还有一些空间刚好足以放下一个item，那这时候，item之间的距离就是刚好等于minimumInteritemSpacing。但是如果某一行的结尾处还多出一些空间，Layout就会增大item之间的距离，直到最后一个item紧贴到尾部边缘。</p>

<p><img class="center" src="http://lijunwu.github.io/images/2016-07-29-UICollectionView/07.png" width="513"></p>

<p>为了解决这个问题，我先研究了下Layout计算布局的过程。官网上有一张图，大概描述了这个过程中重要的三步：</p>

<p><img class="center" src="http://lijunwu.github.io/images/2016-07-29-UICollectionView/08.png" width="697"></p>

<ul>
<li><p>在Collection View第一次展示或者尺寸变化时，会调用Layout的-prepareLayout方法，这是告诉Layout，Collection View准备要向Layout获取布局信息了。当Layout被invalidate之后，collection view向其获取布局信息之前，这个方法会再一次被调用。这个方法中主要是在计算布局之前预处理一些事情。例如：</p>

<ul>
<li>通过Collection View.dataSource获取section的数目及每个section中的item数目；</li>
<li>如果是Flow Layout布局方式，会向Flow Layout Delegate获取每个item的大小及Header、Footer的尺寸。</li>
</ul>


<p>  在这一步，需要计算出足够的信息，为第二步做准备；</p></li>
<li><p>接着，Collection View会调用Layout的-collectionViewContentSize方法，这个方法需要根据前面的计算信息，返回给Collection View整个内容区域的大小，这样Collection View可以确定其内容滚动的方向。在Flow Layout的默认实现中，它会调整内容的布局，使其只在一个方向滚动。</p></li>
<li>在确定了Collection View的滚动方向后，Collection View调用Layout的layoutAttributesForElementsInRect:方法来获取指定区域的所有view的布局属性。</li>
</ul>


<p>在这三步完成之后，布局过程基本就完成了。在这之后，所有cell和view的熟悉都不会改变，除非你调用Layout的invalidateLayout方法，这个方法会让你上面三步布局过程再次执行一遍。Collection View本身也会调用Layout的invalidateLayout方法。当你去滚动Collection View时，如果Layout对象的-shouldInvalidateLayoutForBoundsChange:方法返回YES，那么也会触发invalidateLayout被执行。</p>

<p>通过上面的分析，可以看出来，Flow Layout在计算布局过程的第一步时，自动改变了item的一些位置属性。那么我们可以在这一步之后，对所有view的位置做个校准，然后再返回给Collection View。于是，我们创建了一个UICollectionViewFlowLayout的子类，重写了其layoutAttributesForElementsInRect：方法，主要代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">currentLayoutAttributes</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">!=</span> <span class="n">prevLayoutAttributes</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">CGRect</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">currentLayoutAttributes</span><span class="p">.</span><span class="n">frame</span><span class="p">;</span>
</span><span class='line'>    <span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">padding</span><span class="p">;</span>
</span><span class='line'>    <span class="n">currentLayoutAttributes</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">origin</span> <span class="o">+</span> <span class="n">interitemSpace</span> <span class="o">+</span> <span class="n">currentLayoutAttributes</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">&lt;</span> <span class="nb">self</span><span class="p">.</span><span class="n">collectionViewContentSize</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">CGRect</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">currentLayoutAttributes</span><span class="p">.</span><span class="n">frame</span><span class="p">;</span>
</span><span class='line'>    <span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">origin</span> <span class="o">+</span> <span class="n">interitemSpace</span><span class="p">;</span>
</span><span class='line'>    <span class="n">currentLayoutAttributes</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>要注意的是，这里直接修改了缓存在Layout中的attributes。</p>

<p>当我们执行reloadData操作时，会触发invalidateLayout，Layout会重新计算一遍布局，把三个步骤再执行一遍，计算完布局信息然后更新view的时候，会有一个从过渡动画，这时候Layout会有两个方法被调用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">UICollectionViewLayoutAttributes</span> <span class="o">*</span><span class="p">)</span><span class="nf">finalLayoutAttributesForDisappearingItemAtIndexPath:</span><span class="p">(</span><span class="bp">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">itemIndexPath</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">UICollectionViewLayoutAttributes</span> <span class="o">*</span><span class="p">)</span><span class="nf">initialLayoutAttributesForAppearingItemAtIndexPath:</span><span class="p">(</span><span class="bp">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">itemIndexPath</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于所有即将disappear的view，通过第一个方法获取这些view的final attribute，然后执行一个渐变消失的动画，从现在的状态过渡到final状态。
对于即将要appear的view，通过第二个方法获取他们initial attribute，这个方法内部会调用layoutAttributesForItemAtIndexPath：方法，它所获得的attribute是通过计算来的，与缓存在Layout中的attribute是不一样的。过渡动画是从view的initial attribute状态到Layout中缓存的attribute状态，所以会看到view有一个位置上的变化。因此，也需要重写layoutAttributesForItemAtIndexPath：方法，返回一致的attribute。</p>

<h4>参考链接：</h4>

<ul>
<li>王巍：<a href="https://onevcat.com/2012/06/introducing-collection-views/">UICollectionView基本介绍</a>、<a href="https://onevcat.com/2012/08/advanced-collection-view/">UICollectionView进阶</a></li>
<li>纵横而乐：<a href="http://www.jianshu.com/p/40868928a1cf">创建自定义UICollectionView layout</a></li>
<li>官方指南：<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012334-CH1-SW1">Collection View Programming Guide for iOS</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSDate & NSDateFormatter]]></title>
    <link href="http://lijunwu.github.io/blog/2016/06/13/nsdatede-ge-shi-hua/"/>
    <updated>2016-06-13T13:20:55+08:00</updated>
    <id>http://lijunwu.github.io/blog/2016/06/13/nsdatede-ge-shi-hua</id>
    <content type="html"><![CDATA[<p> iOS/MacOS系统中，用NSDate这个类来表示日期和时间。开发中，我们常常需要将一个NSDate对象格式化为NSString对象）或者将一个NSString对象解析为NSDate对象，或者反之。这两个过程都需要借助NSDateFormatter这个类，这个文章主要介绍NSDateFormatter的一些用法。</p>

<h4>NSDateFormatter</h4>

<p>NSDateFormatter表示的是一种日期的格式，通过NSDateFormatter，就可以进行NSDate和NSString的之间的转换。date format提供了一些可以配置的属性，最常用到的有下面几个：</p>

<ul>
<li>locale</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span><span class="p">(</span><span class="k">copy</span><span class="p">)</span> <span class="bp">NSLocale</span> <span class="o">*</span><span class="n">locale</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>NSLocale对象包含了语言、地区等一些信息，formatter在进行格式转换时需要参考NSLocale对象，它需要知道转化前的字符串的语言，或者要把NSDate转化成什么语言的字符串，是显示『星期三』还是『Wednesday』。如果没有给formatter指定locale，那么它会取当前系统中的这个值。每一个NSLocale实例对应着一个地区标识符，例如en_US，fr_FR，ja_JP和en_GB，这些标识符包含一个语言码（例如en代表英语）和一个地区码（例如US代表美国）。</p>

<p><img class="center" src="http://lijunwu.github.io/images/2016-07-06—NSDate/01.jpg" width="500"></p>

<ul>
<li>timeZone</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span><span class="p">(</span><span class="k">copy</span><span class="p">)</span> <span class="bp">NSTimeZone</span> <span class="o">*</span><span class="n">timeZone</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于一个给定的date，在不同时区所表示的时间是不同的。同locale一样，如果这里不设置timeZone，formatter就会默认使用系统的timeZone。创建一个时区有两种方式：一是设置相对于中时区的时间差，二是指定时区的名称。下图表示了当前时间，分别设置为中时区和东八区所显示出来的时间。</p>

<p><img class="center" src="http://lijunwu.github.io/images/2016-07-06—NSDate/02.jpg" width="400"></p>

<ul>
<li>dateStyle、timeStyle</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="n">NSDateFormatterStyle</span> <span class="n">dateStyle</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="n">NSDateFormatterStyle</span> <span class="n">timeStyle</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>系统为我们预定义了几种时间显示格式，我们只需要选择并设置合适的formatter style就可以。</p>

<ul>
<li>dateFormat</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span><span class="p">(</span><span class="k">copy</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">dateFormat</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果我们需要自定义时间显示的样式，或者要将一个自定义样式的时间字符串转化为NSDate对象，我们就需要设置这里的dateFormat；这个后面详细举例。</p>

<h4>使用系统预定义样式展示日期和时间</h4>

<p>使用系统预定义样式的代码比较简单，只需要设置formatter的dataStyle或timeStyle就可以了，但是要注意，日期（年月日）和时间需要分开设置，不设置就不会显示；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>    <span class="bp">NSDate</span> <span class="o">*</span><span class="n">date</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">NSDateFormatter</span> <span class="o">*</span><span class="n">formatter</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDateFormatter</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'>    <span class="n">formatter</span><span class="p">.</span><span class="n">dateStyle</span> <span class="o">=</span> <span class="n">NSDateFormatterNoStyle</span><span class="p">;</span>
</span><span class='line'>    <span class="n">formatter</span><span class="p">.</span><span class="n">timeStyle</span> <span class="o">=</span> <span class="n">NSDateFormatterNoStyle</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">preNoStyleLB</span> <span class="nl">setText</span><span class="p">:[</span><span class="n">formatter</span> <span class="nl">stringFromDate</span><span class="p">:</span><span class="n">date</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure>


<p>下图展示了不同style下的时间显示样式。</p>

<p><img class="center" src="http://lijunwu.github.io/images/2016-07-06—NSDate/03.jpg" width="400"></p>

<h4>使用自定义的Formatter string展示日期和时间</h4>

<p>自定义时间格式需要设置formatter的dateFormat属性，这个格式字符串使用Unicode Technical #35标准中的格式匹配模式。如果格式匹配符是”yyyy-MM-dd HH:mm:ss”，那转化后的时间字符串就是”2016-06-17 23:40:44”这样子的。自定义时间格式的使用主要有两种场景：</p>

<ul>
<li>Fixed Formats（固定格式）</li>
<li>Custom Formats for User-Visible Dates</li>
</ul>


<p>接下来说说这两种场景的使用：</p>

<h5>Fixed Formats（固定格式）</h5>

<p>这个比较好理解，就是格式不变嘛，直接将一个表示时间格式的字符串设置为dataFormat。我们前一个例子就是固定格式的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSDateFormatter</span> <span class="o">*</span><span class="n">dateFormatter</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSDateFormatter</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">setDateFormat</span><span class="p">:</span><span class="s">@&quot;yyyy-MM-dd &#39;at’ HH:mm EEE”];</span>
</span><span class='line'>
</span><span class='line'><span class="bp">NSDate</span> <span class="o">*</span><span class="n">date</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">];</span>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">formattedDateString</span> <span class="o">=</span> <span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">stringFromDate</span><span class="p">:</span><span class="n">date</span><span class="p">];</span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;formattedDateString: %@&quot;</span><span class="p">,</span> <span class="n">formattedDateString</span><span class="p">);</span>
</span><span class='line'><span class="c1">// formattedDateString: 2016-06-17 at 13:00 周五</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：如果没有设置locale和time zone的话，会默认参考用户偏好设置中的相关设置。</p>

<h5>Custom Formats for User-Visible Dates</h5>

<p>这一种不太好翻译，大概理解的意思就是会根据locale，也就是当前用户的偏好习惯来自动生成一个 format string（fixed formats是写死的）。</p>

<p>你只提供你需要显示的date components，要显示日期？星期几？还是时间？等等，然后date formatter会根据你提供的locale，给这个format string在合适的地方加上一些标号，并按照locale里包含的用户习惯重新对这个date components排序。下面有个例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">formatString</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDateFormatter</span> <span class="nl">dateFormatFromTemplate</span><span class="p">:</span><span class="s">@&quot;EdMMM&quot;</span> <span class="nl">options</span><span class="p">:</span><span class="mi">0</span>
</span><span class='line'>                                          <span class="nl">locale</span><span class="p">:[</span><span class="bp">NSLocale</span> <span class="nl">localeWithLocaleIdentifier</span><span class="p">:@</span><span class="err">“</span><span class="n">en_US</span><span class="s">&quot;]];</span>
</span><span class='line'><span class="bp">NSDateFormatter</span> <span class="o">*</span><span class="n">dateFormatter</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSDateFormatter</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">setDateFormat</span><span class="p">:</span><span class="n">formatString</span><span class="p">];</span>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">todayString</span> <span class="o">=</span> <span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">stringFromDate</span><span class="p">:[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">]];</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;todayString: %@&quot;</span><span class="p">,</span> <span class="n">todayString</span><span class="p">);</span>
</span><span class='line'><span class="c1">// 代码打印的结果是： 周五 6月17</span>
</span></code></pre></td></tr></table></div></figure>


<p>为什么这是了locale是”en_US”，打印出来的日期却还是中文呢？</p>

<p>原因是上面这段代码中，dataFormatter的locale使用了系统默认的locale值，而系统语言是”zh_CN”，我们提供的locale只是为了生成一个给美国人（en_US）看的，符合他们阅读习惯的一个format string，这个值并没有影响到dataFormatter本身，如果想要让打印的日期是英文，那我们必须加上下面这一行代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">setLocale</span><span class="p">:[</span><span class="bp">NSLocale</span> <span class="nl">localeWithLocaleIdentifier</span><span class="p">:</span><span class="s">@&quot;en_US&quot;</span><span class="p">]];</span><span class="err">`</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是打印的结果就是： Fri,Jun 17。</p>

<p>一般的话，dataFormatter的locale和生成Format string时用的locale是一样的，毕竟展示出来的语言要符合该语言本身的使用习惯。</p>

<p>下面这个例子就是说明了英国和美国，在显示日期上的不同习惯。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSLocale</span> <span class="o">*</span><span class="n">usLocale</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSLocale</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithLocaleIdentifier</span><span class="p">:</span><span class="s">@&quot;en_US&quot;</span><span class="p">];</span>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">usFormatString</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDateFormatter</span> <span class="nl">dateFormatFromTemplate</span><span class="p">:</span><span class="s">@&quot;EdMMM&quot;</span> <span class="nl">options</span><span class="p">:</span><span class="mi">0</span> <span class="nl">locale</span><span class="p">:</span><span class="n">usLocale</span><span class="p">];</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;usFormatterString: %@&quot;</span><span class="p">,</span> <span class="n">usFormatString</span><span class="p">);</span>
</span><span class='line'><span class="c1">// Output: usFormatterString: EEE, MMM d.</span>
</span><span class='line'>
</span><span class='line'><span class="bp">NSLocale</span> <span class="o">*</span><span class="n">gbLocale</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSLocale</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithLocaleIdentifier</span><span class="p">:</span><span class="s">@&quot;en_GB&quot;</span><span class="p">];</span>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">gbFormatString</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDateFormatter</span> <span class="nl">dateFormatFromTemplate</span><span class="p">:</span><span class="s">@&quot;EdMMM&quot;</span> <span class="nl">options</span><span class="p">:</span><span class="mi">0</span> <span class="nl">locale</span><span class="p">:</span><span class="n">gbLocale</span><span class="p">];</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;gbFormatterString: %@&quot;</span><span class="p">,</span> <span class="n">gbFormatString</span><span class="p">);</span>
</span><span class='line'><span class="c1">// Output: gbFormatterString: EEE d MMM.</span>
</span></code></pre></td></tr></table></div></figure>


<h4>参考链接：</h4>

<ul>
<li>NSHipster.cn ：<a href="http://nshipster.cn/nslocale/">NSLocale</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITextView 限制字符输入]]></title>
    <link href="http://lijunwu.github.io/blog/2015/09/16/uitextview-xian-zhi-zi-fu-shu-ru/"/>
    <updated>2015-09-16T20:48:54+08:00</updated>
    <id>http://lijunwu.github.io/blog/2015/09/16/uitextview-xian-zhi-zi-fu-shu-ru</id>
    <content type="html"><![CDATA[<p>最近项目里有个小需求，就是在文本输入时要限制输入的字数。文本输入控件用的是<code>UITextView</code>和<code>UITextField</code>，通常的做法是，在内容改变时，在这两个类相应的回调方法中检测字数，如果大于某一个值则当前输入的内容不会被显示到控件中。以<code>UITextView</code>为例，我们基本只需要在下面两个回调方法中检测即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 第一个方法：</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">textView:</span><span class="p">(</span><span class="bp">UITextView</span> <span class="o">*</span><span class="p">)</span><span class="nv">textView</span> <span class="nf">shouldChangeTextInRange:</span><span class="p">(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">range</span> <span class="nf">replacementText:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">text</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">textView</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="n">WordLimitOfTitle</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">[</span><span class="n">text</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="s">@&quot;&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 标题字数已达最大，仍然继续输入</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// copy and paste 的情况</span>
</span><span class='line'>        <span class="bp">NSUInteger</span> <span class="n">totalLength</span> <span class="o">=</span> <span class="n">textView</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
</span><span class='line'>        <span class="n">totalLength</span> <span class="o">+=</span> <span class="n">text</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">totalLength</span> <span class="o">&gt;</span> <span class="n">WordLimitOfTitle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="n">text</span> <span class="nl">substringWithRange</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">WordLimitOfTitle</span> <span class="o">-</span> <span class="n">textView</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="n">length</span><span class="p">)];</span>
</span><span class='line'>            <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当用户在键盘上键入一个新的字符或者删除一个字符都会调用这个方法，另外当复制粘贴内容到<code>textView</code>时这个方法也会被调用。删除一个字符时，<code>range</code>的长度为1，<code>text</code>内容为空。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 第二个方法：</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">textViewDidChange:</span><span class="p">(</span><span class="bp">UITextView</span> <span class="o">*</span><span class="p">)</span><span class="nv">textView</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">textView</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">WordLimitOfTitle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="bp">NSString</span> <span class="o">*</span><span class="n">title</span> <span class="o">=</span> <span class="n">textView</span><span class="p">.</span><span class="n">text</span><span class="p">;</span>
</span><span class='line'>        <span class="n">title</span> <span class="o">=</span> <span class="p">[</span><span class="n">title</span> <span class="nl">substringWithRange</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">WordLimitOfTitle</span><span class="p">)];</span>
</span><span class='line'>        <span class="n">textView</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">title</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个方法在文本框内容发生改变时被调用，注意，这个方法只会响应由用户引起的内容改变，不会响应代码发起的内容改变。其实只要在第一个方法中截获内容变化再截断超出部分，基本就能达到我们的预期。</p>

<h3>中文输入法</h3>

<p>下面我们考虑中文输入的问题。（这里我把<code>return</code>健设置为<code>完成</code>，但是貌似只是文字变成了<code>完成</code>而已，实际上不管你设为什么，你按下这个健后拿到的字符都是一样的<code>\n</code>）</p>

<p>这里先说说<code>UITextInput</code>里的<code>markedTextRange</code>属性，就是被标记的文本,它的类型是<code>UITextRange</code>。</p>

<p><code>UITextInput</code>是一个<code>protocol</code>，<code>UITextView</code>、<code>UITextField</code>等文本输入控件都采纳了这个协议。官方文档对<code>markedTextRange</code>的解释如下：</p>

<blockquote><p>If text can be selected, it can be marked. Marked text represents provisionally inserted text that has yet to be confirmed by the user.  It requires unique visual treatment in its display.  If there is any marked text, the selection, whether a caret or an extended range, always resides witihin.
Setting marked text either replaces the existing marked text or, if none is present,inserts it from the current selection.</p></blockquote>

<p>要注意的是：</p>

<p>标记的文本表示键入的文本只是临时性的，还没有被用户确定。外观上它需要与普通文本显示不一样。比如下面这样</p>

<div>
<img src = "https://farm6.staticflickr.com/5707/20845977654_d26e389f3e_z.jpg"  width = 300px>
</div>


<p>除了上面两个回调方法，我们再增加一个回调方法：</p>

<pre><code>- (void)textViewDidChangeSelection:(UITextView *)textView;
</code></pre>

<p>在这三个方法中，我们分别打印<code>textView.text</code>和<code>textView.markedTextRange</code>值。</p>

<p>现在我们切换到中文输入法：</p>

<p><img src="https://farm1.staticflickr.com/652/20845977174_ec03afca87_z.jpg" width="300"></p>

<p>在上面的输入框里我继续按下 <img style = "border:none" src = "https://farm1.staticflickr.com/694/21280634390_7f46dd49b3_z.jpg"" width = 50 >,这时输入框的内容变成了</p>

<p><img src = "https://farm1.staticflickr.com/686/21468673185_679ed4fcc0_z.jpg" width = 300px></p>

<p>并且在<code>tian</code>与<code>a</code>之间多出了一个空格。</p>

<p>我们先来看看这几个方法执行顺序：</p>

<ul>
<li>首先触发的是 <code>- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text;</code> 这个方法。打印结果如下：</li>
</ul>


<p><img src = "https://farm1.staticflickr.com/654/21468672825_45945d13d6_z.jpg" width = 468px></p>

<p>此时<code>markedTextRange</code>表示从第三个字符开始，长度为9所表示的区域（包括中间的空格）。</p>

<p>如果方法返回YES，表示<code>text</code>所表示的文本将会替代指定位置，即<code>range</code>所表示的区域的文本。这里<code>range</code>的<code>length=0</code>，表示这个<code>range</code>是光标插入的位置。这里打印出<code>text</code>的值，却是 <img style = "border:none"  src =" https://farm1.staticflickr.com/675/21477271371_0e05ce20f8_t.jpg" width = 12 >。猜测这里应该会在底层有一套处理逻辑，包括字符转换、联想等。因为我们看到的并不是这个奇怪的字符啊，而是在输入框看到了<code>a</code>。</p>

<ul>
<li>然后被触发的是 <code>- (void)textViewDidChangeSelection:(UITextView *)textView;</code> 这个方法.</li>
</ul>


<p><img src = "https://farm1.staticflickr.com/746/21442460826_d74163b3f5_o.png" width = 486></p>

<p>这时候<code>a</code>已经被追加到文本框中了，<code>textView.text</code>以及<code>textView.markedTextRange</code>都已经发生了变化。这个方法会被调用，主要也是因为<code>textView.markedTextRange</code>发生了变化吧。</p>

<p>注意，这是<code>a</code>跟前面的字符之间还没有出现空格，也就是说 这里只是简单的把一个字符放进了<code>markedTextRange</code>中。</p>

<ul>
<li>紧接着，<code>- (void)textViewDidChange:(UITextView *)textView;</code>
这个方法被调用</li>
</ul>


<p><img src = "https://farm1.staticflickr.com/746/21442460826_d74163b3f5_o.png" width = 486></p>

<p>这个方法里打印结果与前一个方法一样，是因为<code>textView.text</code>改变了所以被调用。</p>

<p>以为到这里结束了？然而，并！没！有！</p>

<p>在上面那个方法执行完了之后，底层应该又去默默地做了一些事情，比如，它觉得"tiana"这一坨好像并不
能组成一个中文字或词组，所以应该把他们分开？结果，它真的这么做了。</p>

<p>这时候，<code>- (void)textViewDidChangeSelection:(UITextView *)textView;</code>这个方法被调用了。</p>

<p>来看看发生了什么？</p>

<p><img src = "https://farm1.staticflickr.com/716/20845975984_2418dd4a05_o.png" width = 476></p>

<p>一个空格出现了！</p>

<p><code>textView.text</code>以及<code>textView.markedTextRange</code>都发生了变化，所以不出意外，接下来还会调用<code>- (void)textViewDidChange:(UITextView *)textView</code>,这里不再写了。</p>

<p>然后我们再看点别的。</p>

<p>假设我现在已经输入了这一段</p>

<p><img src = "https://farm6.staticflickr.com/5760/21280849488_7dbbfdcd13_o.png" width = 407></p>

<p>当选择<code>我是</code>后，这几个方法又是怎么调用的呢？</p>

<p>这次因为没有键入新的内容，所以<code>- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text;</code> 不会被调用。</p>

<p>先被调用的是<code>- (void)textViewDidChangeSelection:(UITextView *)textView；</code>方法：</p>

<p><img src = "https://farm6.staticflickr.com/5830/21468671185_c92fde6005_o.png" width = 472></p>

<p>这个方法中，<code>markedTextRange</code>已经被更改了，<code>textView.text = “我是ddmgwgmmgddwgpgjamg”</code>, 所以这个方法之后会调用<code>- (void)textViewDidChange:(UITextView *)textView；</code>这个方法，打印内容与这里一样，不赘述。</p>

<p>等等，为什么<code>textView.text</code>的值是<code>我是ddmgwgmmgddwgpgjamg</code>而不是<code>我是fengzhongdeyipilang"</code>?! 而且空格也不见了?! 咕~~(╯﹏╰)b，这里输入法已经将之前所有预测的字符全部改成了按键里的第一个字母了，并去掉了空格，也就是这里去掉了所有它自己推测的部分。因为在用户确认了部分文字后，它要对剩下的字符重新预测，因此，先要让所有输入都回到初始状态，然后对剩下的未确定的部分重新推算并在合适的位置加入空格。这样又会导致这两个方法再被调用一遍。</p>

<p><code>- (void)textViewDidChangeSelection:(UITextView *)textView</code>这个方法第二次被调用后，打印内容：</p>

<p><img src = "https://farm1.staticflickr.com/770/21477270021_6dd106ba62_o.png" width = 474></p>

<p>看，空格又回来了！但是，慢着，哪里不对？！输入法不仅加回了空格，还改变了文本框中显示的字符。因为这些字符是输入法推测出来的，所以每次输入一个字符、删除一个字符，输入法会根据当前剩下的所有未确定字符实时推测可能的组合情况，并加入空格。记住这一点很重要，因为我曾将尝试在<code>markedTextRange</code>不为空时去截断<code>textView.text</code>的内容（有个小需求是要检测特定字符，不让其显示到文本框），然后我发现所有一切都变得一团糟。比方说，当你获取到<code>textView.text</code>的值，并截取一段，然后重新设置<code>textView.text</code>之后，你会发现<code>markedTextRanged</code>变为nil，这时候还必须重新设置<code>markedTextRange</code>的值，否则你将会遇到一些奇奇怪怪的现象.</p>

<p>所以最终，我的方案是，只有在<code>markedTextRange==nil</code>时，才会对输入文本做检测，例如字数限制，字符检测，这种情况下再截断就不会有问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式-抽象工厂]]></title>
    <link href="http://lijunwu.github.io/blog/2015/01/24/she-ji-mo-shi-chou-xiang-gong-han/"/>
    <updated>2015-01-24T19:15:28+08:00</updated>
    <id>http://lijunwu.github.io/blog/2015/01/24/she-ji-mo-shi-chou-xiang-gong-han</id>
    <content type="html"><![CDATA[<h2>什么是抽象工厂</h2>

<p style="color:#666666;font-weight:bold;font-size:18px;line-height: 130%;text-indent:20pt">
提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体的类。它涉及多个类型的对象的创建，一系列相关类的好的模式，应该作为一种抽象，不为客户所见。抽象工厂模式可以提供这种抽象，从而不暴露创建过程中任何不必要的细节或所创建的对象的确切类型。
</p>


<div style="text-align:center">
<img src = "http://lijunwu.github.io/images/抽象工厂类图.png" style = "border:1px dashed #930f83;align:center"/>
</div>


<p><p style = "text-indent:20pt;">对于用户来说，他只知道AbstractFactory和AbstractProducts.至于这些工厂和产品的具体的结构和实现细节对用户来说都像一个放在工厂类里面的黑盒一样。每种产品甚至都不知道是哪个类负责创建他们。只有ConcreteFactory知道如何创建产品以及创建什么样的产品给用户。</p>

<h2>抽象工厂VS.工厂方法</h2>

<p><p style = "text-indent:20pt;">抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。</p>

<p><p style = "text-indent:20pt;">在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。我们依然拿生产汽车的例子来说明他们之间的区别。
<div style="text-align:center">
<img src = "http://lijunwu.github.io/images/抽象工厂VS.工厂方法.png" style = "border:1px dashed #930f83;align:center"/>
</div></p>

<h2>使用抽象工厂的效果</h2>

<p><ol>
<li> 它分离了具体的类</li>
一个工厂封装了创建产品对象的责任和过程，它将客户与类的实现分离。客户通过抽象接口操作实例。产品的类名也在具体工厂的实现中被分离，他们不出现在客户代码中。
<li>易于交换产品系列</li>
改变具体的工厂即可以使用不同的产品配置，因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。
<li>有利于产品一致性</li>
当一个系列中的产品被设计成一起工作时，一个应用一次只能使用同一个系列中的对象。
<li>难以支持新种类的产品</li>
抽象工厂接口确定了可以被创建的产品集合。要支持新种类的产品，就要扩展该工厂接口，这将涉及到AbstractFactory类及其所有子类的改变。
</ol></p>

<h2>抽象工厂的实现</h2>

<h3>可能会用到的一些有用的技术</h3>

<p><ol>
<li>将工厂作为单例</li>
一个应用中一般每个产品系列只需要一个ConcreteFactory的实例，因为工厂通常最好实现为一个Singleton。
<li>创建产品</li>
抽象工厂仅声明一个创建产品的接口，正在创建产品的是由ConcreteCreator子类实现的。最通常的一个方法是为每个产品定义一个工厂方法（工厂方法）,一个具体的工厂将为每个产品重新定义该工厂方法以指定产品。虽然这样的实现很简单，但它却要求每个产品系列都要有一个新的具体的工厂子类，即使这些产品系列的差别很小。
如果有多个可能的产品系列，具体工厂也可以使用Prototype模式来实现。具体工厂使用产品系列中每一个产品的原型实例来初始化。且它通过复制它的原型来创建新的产品。在基于原型的方法中，使得不是每个新的产品系列都需要一个新的具体工厂类。
<li>定义可扩展的工厂</li>
抽象工厂通常为每一种它可以生产的产品定义一个操作。产品的种类被编码在操作行构中。增加一种新的产品要求改变抽象工厂的接口以及所有与它相关的类。一个更加灵活但不太安全的设计是给创建对象的操作增加一个参数。这个参数可以标识这个被创建的产品的种类。它可以是一个类标识符，一个整数、一个字符串等。
</ol></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式-工厂方法]]></title>
    <link href="http://lijunwu.github.io/blog/2015/01/06/she-ji-mo-shi-gong-han-fang-fa/"/>
    <updated>2015-01-06T13:37:53+08:00</updated>
    <id>http://lijunwu.github.io/blog/2015/01/06/she-ji-mo-shi-gong-han-fang-fa</id>
    <content type="html"><![CDATA[<h2>什么是工厂方法</h2>

<p style="color:#666666;font-weight:bold;font-size:18px;line-height: 130%;text-indent:20pt">定义创建对象的接口，让子类决定实例化哪一个对象。工厂方法使得一个类的初始化延迟到其子类。工厂方法也被称为虚构造器。</p>


<div style="text-align:center">
<img src = "http://lijunwu.github.io/images/工厂方法类图.png" style = "border:1px dashed #930f83;align:center"/>
</div>


<p><p style = "text-indent:20pt;">抽象的Product定义了工厂方法创建的对象接口。ConcreteProduct实现了Product定义的接口。Creator定义了一个工厂方法，这个方法会返回一个Product对象，当然也可以为这个工厂方法提供一个默认的实现，返回一个默认的ConcreteProduct对象。Creator的其他方法可以调用这个工厂方法创建Product对象。ConcreteCreator是Creator的子类，它重载了工厂方法，并返回一个ConcreteProduct的实例。</p>

<h2>何时使用工厂方法</h2>

<p><p>当遇到以下情形时，可以考虑使用工厂模式
<ol>
<li>编译时无法准确预期想要创建的对象的类；
<li>类想让其子类决定在运行时创建什么；
<li>类有若干辅助类为其子类，而你想将返回哪个类这一信息局部化
</ol></p>

<h4>Cocoa中的例子</h4>

<p><p style = "text-indent:20pt;">Cocoa中使用这一架构的例子有NSNumber。尽管可以使用常见的alloc init两步法创建NSNumber的实例，但这基本上没做什么，除非你使用预先定义的类工厂方法来创建一个有意义的实例。例如，
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="bp">NSNumber</span> <span class="nl">numberWithBool</span><span class="p">:</span><span class="nb">YES</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>这个方法会得到一个NSCFBoolean的实例，这个实例包含传给类工厂方法的布尔值。</p>

<h2>使用工厂方法的效果</h2>

<p><p style="text-indent:20pt">工厂方法不再将与特定应用有关的类绑定到你的代码中，代码仅处理Product接口；因此它可以与用户定义的任何ConcreteProduct类一起使用。
<p style="text-indent:20pt">工厂方法的一个潜在缺点在于用户仅仅为了创建一个特定的ConcreteProduct对象，就不得不创建Creator的子类。当创建Creator子类不必需时，客户现在必然要处理类演化的其他方面；但是当客户无论如何必须创建Creator的子类时，创建子类也是可行的。</p>

<h4>下面是Factory Method模式的另外两种效果</h4>

<p><ol>
<li>为子类提供挂钩（hook）</li>
用工厂方法在一个类的内部创建对象通常比直接创建对象更灵活。Factory Method给子类一个挂钩以提供对象的扩展版本。
Creator可以定义工厂方法的合理的缺省实现。
<li>连接平行的类层次</li>
当一个类将它的职责委托给一个独立的类的时候，就产生了平行类层次。
工厂方法将哪些类应一同工作的信息局部化了。
</ol></p>

<h2>工厂方法的实现</h2>

<p><p style = "text-indent:20pt;">当应用Factory Method模式时，应考虑一下问题
<ol>
    <li>主要有两种不同的情况
        <ul>
            <li>Creator是一个抽象类，并且不提供它所声明的工厂方法的实现。这种情况需要子类来定义实现。它避免了不得不实例化不可预见类的问题
            <li>Creator是一个具体的类，而且为工厂方法提供一个缺省的实现。它所遵循的准则是：用一个独立的操作创建对象，这样子类才能重新定义他们的创建方式。
        </ul>
    </li>
    <li>参数化工厂方法</li>
    工厂方法采用一个标识要背创建的对象种类的参数。
</ol></p>

<h2>典型应用[来自网络]</h2>

<p><p style = "text-indent:20pt;">要说明工厂模式的优点，可能没有比组装汽车更合适的例子了。场景是这样的：汽车由发动机、轮、底盘组成，现在需要组装一辆车交给调用者。假如不使用工厂模式，代码如下：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">Engine</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">getEngine</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Engine</span> <span class="o"><em></span><span class="n">engine</span> <span class="o">=</span> <span class="p">[</span><span class="n">Engine</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;这是汽车的发动机&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">engine</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Underpan</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">getUnderpan</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Underpan</span> <span class="o"></em></span><span class="n">underpan</span> <span class="o">=</span> <span class="p">[</span><span class="n">Underpan</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;这是汽车的底盘&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">underpan</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Wheel</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">getWheel</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Wheel</span> <span class="err">\</span><span class="o"><em></span><span class="n">wheel</span> <span class="o">=</span> <span class="p">[</span><span class="n">Wheel</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;这是汽车的轮胎&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">wheel</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Car</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">makeCarWithEngine:</span><span class="p">(</span><span class="n">Engine</span> <span class="o"></em></span><span class="p">)</span><span class="nv">engine</span> <span class="nf">underpan:</span><span class="p">(</span><span class="n">Underpan</span> <span class="o"><em></span><span class="p">)</span><span class="nv">underpan</span> <span class="nf">wheel:</span><span class="p">(</span><span class="n">Wheel</span> <span class="o"></em></span><span class="p">)</span><span class="nv">wheel</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Car</span> <span class="o"><em></span><span class="n">car</span> <span class="o">=</span> <span class="p">[</span><span class="n">Car</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">car</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Client</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">Car</span> <span class="o"></em></span><span class="p">)</span><span class="nf">mainMethod</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Engine</span> <span class="o"><em></span><span class="n">engine</span> <span class="o">=</span> <span class="p">[</span><span class="n">Engine</span> <span class="n">getEngine</span><span class="p">];</span>
</span><span class='line'>    <span class="n">Underpan</span> <span class="o"></em></span><span class="n">underpan</span> <span class="o">=</span> <span class="p">[</span><span class="n">Underpan</span> <span class="n">getUnderpan</span><span class="p">];</span>
</span><span class='line'>    <span class="n">Wheel</span> <span class="o"><em></span><span class="n">wheel</span> <span class="o">=</span> <span class="p">[</span><span class="n">Wheel</span> <span class="n">getWheel</span><span class="p">];</span>
</span><span class='line'>    <span class="n">Car</span> <span class="o"></em></span><span class="n">car</span> <span class="o">=</span> <span class="p">[</span><span class="n">Car</span> <span class="nl">makeCarWithEngine</span><span class="p">:</span><span class="n">engine</span> <span class="nl">underpan</span><span class="p">:</span><span class="n">underpan</span> <span class="nl">wheel</span><span class="p">:</span><span class="n">wheel</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">car</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p><p style="text-indent:20pt">可以看到，调用者为了组装汽车还需要另外实例化发动机、底盘和轮胎，而这些汽车的组件是与调用者无关的，严重违反了迪米特法则，耦合度太高。并且非常不利于扩展。另外，本例中发动机、底盘和轮胎还是比较具体的，在实际应用中，可能这些产品的组件也都是抽象的，调用者根本不知道怎样组装产品。假如使用工厂方法的话，整个架构就显得清晰了许多。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">Factory</span> : <span class="bp">NSObject</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="n">Car</span> <span class="o"><em></span><span class="p">)</span><span class="nf">makeCar</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Factory</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="n">Car</span> <span class="o"></em></span><span class="p">)</span><span class="nf">makeCar</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Engine</span> <span class="o"><em></span><span class="n">engine</span> <span class="o">=</span> <span class="p">[</span><span class="n">Engine</span> <span class="n">getEngine</span><span class="p">];</span>
</span><span class='line'>    <span class="n">Underpan</span> <span class="o"></em></span><span class="n">underpan</span> <span class="o">=</span> <span class="p">[</span><span class="n">Underpan</span> <span class="n">getUnderpan</span><span class="p">];</span>
</span><span class='line'>    <span class="n">Wheel</span> <span class="o"><em></span><span class="n">wheel</span> <span class="o">=</span> <span class="p">[</span><span class="n">Wheel</span> <span class="n">getWheel</span><span class="p">];</span>
</span><span class='line'>    <span class="n">Car</span> <span class="o"></em></span><span class="n">car</span> <span class="o">=</span> <span class="p">[</span><span class="n">Car</span> <span class="nl">makeCarWithEngine</span><span class="p">:</span><span class="n">engine</span> <span class="nl">underpan</span><span class="p">:</span><span class="n">underpan</span> <span class="nl">wheel</span><span class="p">:</span><span class="n">wheel</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">car</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Client</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">Car</span> <span class="o"><em></span><span class="p">)</span><span class="nf">mainMethod</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Car</span> <span class="o"></em></span><span class="n">car</span> <span class="o">=</span> <span class="p">[</span><span class="n">Factory</span> <span class="n">makeCar</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">car</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p><p style="text-indent:20pt">  使用工厂方法后，调用端的耦合度大大降低了。并且对于工厂来说，是可以扩展的，以后如果想组装其他的汽车，只需要再增加一个工厂类的实现就可以。无论是灵活性还是稳定性都得到了极大的提高。</p>
]]></content>
  </entry>
  
</feed>
