<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Amy's Blog]]></title>
  <link href="http://lijunwu.github.io/atom.xml" rel="self"/>
  <link href="http://lijunwu.github.io/"/>
  <updated>2016-07-06T15:47:36+08:00</updated>
  <id>http://lijunwu.github.io/</id>
  <author>
    <name><![CDATA[吴丽君]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[NSDate & NSDateFormatter]]></title>
    <link href="http://lijunwu.github.io/blog/2016/06/13/nsdatede-ge-shi-hua/"/>
    <updated>2016-06-13T13:20:55+08:00</updated>
    <id>http://lijunwu.github.io/blog/2016/06/13/nsdatede-ge-shi-hua</id>
    <content type="html"><![CDATA[<p> iOS/MacOS系统中，用NSDate这个类来表示日期和时间。开发中，我们常常需要将一个NSDate对象格式化为NSString对象）或者将一个NSString对象解析为NSDate对象，或者反之。这两个过程都需要借助NSDateFormatter这个类，这个文章主要介绍NSDateFormatter的一些用法。</p>

<h4>NSDateFormatter</h4>

<p>NSDateFormatter表示的是一种日期的格式，通过NSDateFormatter，就可以进行NSDate和NSString的之间的转换。date format提供了一些可以配置的属性，最常用到的有下面几个：</p>

<ul>
<li>locale</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span><span class="p">(</span><span class="k">copy</span><span class="p">)</span> <span class="bp">NSLocale</span> <span class="o">*</span><span class="n">locale</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>NSLocale对象包含了语言、地区等一些信息，formatter在进行格式转换时需要参考NSLocale对象，它需要知道转化前的字符串的语言，或者要把NSDate转化成什么语言的字符串，是显示『星期三』还是『Wednesday』。如果没有给formatter指定locale，那么它会取当前系统中的这个值。每一个NSLocale实例对应着一个地区标识符，例如en_US，fr_FR，ja_JP和en_GB，这些标识符包含一个语言码（例如en代表英语）和一个地区码（例如US代表美国）。</p>

<p><img class="center" src="http://lijunwu.github.io/images/2016-07-06—NSDate/01.jpg" width="500"></p>

<ul>
<li>timeZone</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span><span class="p">(</span><span class="k">copy</span><span class="p">)</span> <span class="bp">NSTimeZone</span> <span class="o">*</span><span class="n">timeZone</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于一个给定的date，在不同时区所表示的时间是不同的。同locale一样，如果这里不设置timeZone，formatter就会默认使用系统的timeZone。创建一个时区有两种方式：一是设置相对于中时区的时间差，二是指定时区的名称。下图表示了当前时间，分别设置为中时区和东八区所显示出来的时间。</p>

<p><img class="center" src="http://lijunwu.github.io/images/2016-07-06—NSDate/02.jpg" width="400"></p>

<ul>
<li>dateStyle、timeStyle</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="n">NSDateFormatterStyle</span> <span class="n">dateStyle</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="n">NSDateFormatterStyle</span> <span class="n">timeStyle</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>系统为我们预定义了几种时间显示格式，我们只需要选择并设置合适的formatter style就可以。</p>

<ul>
<li>dateFormat</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span><span class="p">(</span><span class="k">copy</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">dateFormat</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果我们需要自定义时间显示的样式，或者要将一个自定义样式的时间字符串转化为NSDate对象，我们就需要设置这里的dateFormat；这个后面详细举例。</p>

<h4>使用系统预定义样式展示日期和时间</h4>

<p>使用系统预定义样式的代码比较简单，只需要设置formatter的dataStyle或timeStyle就可以了，但是要注意，日期（年月日）和时间需要分开设置，不设置就不会显示；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>    <span class="bp">NSDate</span> <span class="o">*</span><span class="n">date</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">NSDateFormatter</span> <span class="o">*</span><span class="n">formatter</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDateFormatter</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'>    <span class="n">formatter</span><span class="p">.</span><span class="n">dateStyle</span> <span class="o">=</span> <span class="n">NSDateFormatterNoStyle</span><span class="p">;</span>
</span><span class='line'>    <span class="n">formatter</span><span class="p">.</span><span class="n">timeStyle</span> <span class="o">=</span> <span class="n">NSDateFormatterNoStyle</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">preNoStyleLB</span> <span class="nl">setText</span><span class="p">:[</span><span class="n">formatter</span> <span class="nl">stringFromDate</span><span class="p">:</span><span class="n">date</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure>


<p>下图展示了不同style下的时间显示样式。</p>

<p><img class="center" src="http://lijunwu.github.io/images/2016-07-06—NSDate/03.jpg" width="400"></p>

<h4>使用自定义的Formatter string展示日期和时间</h4>

<p>自定义时间格式需要设置formatter的dateFormat属性，这个格式字符串使用Unicode Technical #35标准中的格式匹配模式。如果格式匹配符是”yyyy-MM-dd HH:mm:ss”，那转化后的时间字符串就是”2016-06-17 23:40:44”这样子的。自定义时间格式的使用主要有两种场景：</p>

<ul>
<li>Fixed Formats（固定格式）</li>
<li>Custom Formats for User-Visible Dates</li>
</ul>


<p>接下来说说这两种场景的使用：</p>

<h5>Fixed Formats（固定格式）</h5>

<p>这个比较好理解，就是格式不变嘛，直接将一个表示时间格式的字符串设置为dataFormat。我们前一个例子就是固定格式的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSDateFormatter</span> <span class="o">*</span><span class="n">dateFormatter</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSDateFormatter</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">setDateFormat</span><span class="p">:</span><span class="s">@&quot;yyyy-MM-dd &#39;at’ HH:mm EEE”];</span>
</span><span class='line'>
</span><span class='line'><span class="bp">NSDate</span> <span class="o">*</span><span class="n">date</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">];</span>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">formattedDateString</span> <span class="o">=</span> <span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">stringFromDate</span><span class="p">:</span><span class="n">date</span><span class="p">];</span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;formattedDateString: %@&quot;</span><span class="p">,</span> <span class="n">formattedDateString</span><span class="p">);</span>
</span><span class='line'><span class="c1">// formattedDateString: 2016-06-17 at 13:00 周五</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：如果没有设置locale和time zone的话，会默认参考用户偏好设置中的相关设置。</p>

<h5>Custom Formats for User-Visible Dates</h5>

<p>这一种不太好翻译，大概理解的意思就是会根据locale，也就是当前用户的偏好习惯来自动生成一个 format string（fixed formats是写死的）。</p>

<p>你只提供你需要显示的date components，要显示日期？星期几？还是时间？等等，然后date formatter会根据你提供的locale，给这个format string在合适的地方加上一些标号，并按照locale里包含的用户习惯重新对这个date components排序。下面有个例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">formatString</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDateFormatter</span> <span class="nl">dateFormatFromTemplate</span><span class="p">:</span><span class="s">@&quot;EdMMM&quot;</span> <span class="nl">options</span><span class="p">:</span><span class="mi">0</span>
</span><span class='line'>                                          <span class="nl">locale</span><span class="p">:[</span><span class="bp">NSLocale</span> <span class="nl">localeWithLocaleIdentifier</span><span class="p">:@</span><span class="err">“</span><span class="n">en_US</span><span class="s">&quot;]];</span>
</span><span class='line'><span class="bp">NSDateFormatter</span> <span class="o">*</span><span class="n">dateFormatter</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSDateFormatter</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">setDateFormat</span><span class="p">:</span><span class="n">formatString</span><span class="p">];</span>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">todayString</span> <span class="o">=</span> <span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">stringFromDate</span><span class="p">:[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">]];</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;todayString: %@&quot;</span><span class="p">,</span> <span class="n">todayString</span><span class="p">);</span>
</span><span class='line'><span class="c1">// 代码打印的结果是： 周五 6月17</span>
</span></code></pre></td></tr></table></div></figure>


<p>为什么这是了locale是”en_US”，打印出来的日期却还是中文呢？</p>

<p>原因是上面这段代码中，dataFormatter的locale使用了系统默认的locale值，而系统语言是”zh_CN”，我们提供的locale只是为了生成一个给美国人（en_US）看的，符合他们阅读习惯的一个format string，这个值并没有影响到dataFormatter本身，如果想要让打印的日期是英文，那我们必须加上下面这一行代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">setLocale</span><span class="p">:[</span><span class="bp">NSLocale</span> <span class="nl">localeWithLocaleIdentifier</span><span class="p">:</span><span class="s">@&quot;en_US&quot;</span><span class="p">]];</span><span class="err">`</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是打印的结果就是： Fri,Jun 17。</p>

<p>一般的话，dataFormatter的locale和生成Format string时用的locale是一样的，毕竟展示出来的语言要符合该语言本身的使用习惯。</p>

<p>下面这个例子就是说明了英国和美国，在显示日期上的不同习惯。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSLocale</span> <span class="o">*</span><span class="n">usLocale</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSLocale</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithLocaleIdentifier</span><span class="p">:</span><span class="s">@&quot;en_US&quot;</span><span class="p">];</span>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">usFormatString</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDateFormatter</span> <span class="nl">dateFormatFromTemplate</span><span class="p">:</span><span class="s">@&quot;EdMMM&quot;</span> <span class="nl">options</span><span class="p">:</span><span class="mi">0</span> <span class="nl">locale</span><span class="p">:</span><span class="n">usLocale</span><span class="p">];</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;usFormatterString: %@&quot;</span><span class="p">,</span> <span class="n">usFormatString</span><span class="p">);</span>
</span><span class='line'><span class="c1">// Output: usFormatterString: EEE, MMM d.</span>
</span><span class='line'>
</span><span class='line'><span class="bp">NSLocale</span> <span class="o">*</span><span class="n">gbLocale</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSLocale</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithLocaleIdentifier</span><span class="p">:</span><span class="s">@&quot;en_GB&quot;</span><span class="p">];</span>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">gbFormatString</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDateFormatter</span> <span class="nl">dateFormatFromTemplate</span><span class="p">:</span><span class="s">@&quot;EdMMM&quot;</span> <span class="nl">options</span><span class="p">:</span><span class="mi">0</span> <span class="nl">locale</span><span class="p">:</span><span class="n">gbLocale</span><span class="p">];</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;gbFormatterString: %@&quot;</span><span class="p">,</span> <span class="n">gbFormatString</span><span class="p">);</span>
</span><span class='line'><span class="c1">// Output: gbFormatterString: EEE d MMM.</span>
</span></code></pre></td></tr></table></div></figure>


<h4>参考链接：</h4>

<ul>
<li>NSHipster.cn ：<a href="http://nshipster.cn/nslocale/">NSLocale</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITextView 限制字符输入]]></title>
    <link href="http://lijunwu.github.io/blog/2015/09/16/uitextview-xian-zhi-zi-fu-shu-ru/"/>
    <updated>2015-09-16T20:48:54+08:00</updated>
    <id>http://lijunwu.github.io/blog/2015/09/16/uitextview-xian-zhi-zi-fu-shu-ru</id>
    <content type="html"><![CDATA[<p>最近项目里有个小需求，就是在文本输入时要限制输入的字数。文本输入控件用的是<code>UITextView</code>和<code>UITextField</code>，通常的做法是，在内容改变时，在这两个类相应的回调方法中检测字数，如果大于某一个值则当前输入的内容不会被显示到控件中。以<code>UITextView</code>为例，我们基本只需要在下面两个回调方法中检测即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 第一个方法：</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">textView:</span><span class="p">(</span><span class="bp">UITextView</span> <span class="o">*</span><span class="p">)</span><span class="nv">textView</span> <span class="nf">shouldChangeTextInRange:</span><span class="p">(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">range</span> <span class="nf">replacementText:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">text</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">textView</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="n">WordLimitOfTitle</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">[</span><span class="n">text</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="s">@&quot;&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 标题字数已达最大，仍然继续输入</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// copy and paste 的情况</span>
</span><span class='line'>        <span class="bp">NSUInteger</span> <span class="n">totalLength</span> <span class="o">=</span> <span class="n">textView</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
</span><span class='line'>        <span class="n">totalLength</span> <span class="o">+=</span> <span class="n">text</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">totalLength</span> <span class="o">&gt;</span> <span class="n">WordLimitOfTitle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="n">text</span> <span class="nl">substringWithRange</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">WordLimitOfTitle</span> <span class="o">-</span> <span class="n">textView</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="n">length</span><span class="p">)];</span>
</span><span class='line'>            <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当用户在键盘上键入一个新的字符或者删除一个字符都会调用这个方法，另外当复制粘贴内容到<code>textView</code>时这个方法也会被调用。删除一个字符时，<code>range</code>的长度为1，<code>text</code>内容为空。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 第二个方法：</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">textViewDidChange:</span><span class="p">(</span><span class="bp">UITextView</span> <span class="o">*</span><span class="p">)</span><span class="nv">textView</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">textView</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">WordLimitOfTitle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="bp">NSString</span> <span class="o">*</span><span class="n">title</span> <span class="o">=</span> <span class="n">textView</span><span class="p">.</span><span class="n">text</span><span class="p">;</span>
</span><span class='line'>        <span class="n">title</span> <span class="o">=</span> <span class="p">[</span><span class="n">title</span> <span class="nl">substringWithRange</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">WordLimitOfTitle</span><span class="p">)];</span>
</span><span class='line'>        <span class="n">textView</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">title</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个方法在文本框内容发生改变时被调用，注意，这个方法只会响应由用户引起的内容改变，不会响应代码发起的内容改变。其实只要在第一个方法中截获内容变化再截断超出部分，基本就能达到我们的预期。</p>

<h3>中文输入法</h3>

<p>下面我们考虑中文输入的问题。（这里我把<code>return</code>健设置为<code>完成</code>，但是貌似只是文字变成了<code>完成</code>而已，实际上不管你设为什么，你按下这个健后拿到的字符都是一样的<code>\n</code>）</p>

<p>这里先说说<code>UITextInput</code>里的<code>markedTextRange</code>属性，就是被标记的文本,它的类型是<code>UITextRange</code>。</p>

<p><code>UITextInput</code>是一个<code>protocol</code>，<code>UITextView</code>、<code>UITextField</code>等文本输入控件都采纳了这个协议。官方文档对<code>markedTextRange</code>的解释如下：</p>

<blockquote><p>If text can be selected, it can be marked. Marked text represents provisionally inserted text that has yet to be confirmed by the user.  It requires unique visual treatment in its display.  If there is any marked text, the selection, whether a caret or an extended range, always resides witihin.
Setting marked text either replaces the existing marked text or, if none is present,inserts it from the current selection.</p></blockquote>

<p>要注意的是：</p>

<p>标记的文本表示键入的文本只是临时性的，还没有被用户确定。外观上它需要与普通文本显示不一样。比如下面这样</p>

<div>
<img src = "https://farm6.staticflickr.com/5707/20845977654_d26e389f3e_z.jpg"  width = 300px>
</div>


<p>除了上面两个回调方法，我们再增加一个回调方法：</p>

<pre><code>- (void)textViewDidChangeSelection:(UITextView *)textView;
</code></pre>

<p>在这三个方法中，我们分别打印<code>textView.text</code>和<code>textView.markedTextRange</code>值。</p>

<p>现在我们切换到中文输入法：</p>

<p><img src="https://farm1.staticflickr.com/652/20845977174_ec03afca87_z.jpg" width="300"></p>

<p>在上面的输入框里我继续按下 <img style = "border:none" src = "https://farm1.staticflickr.com/694/21280634390_7f46dd49b3_z.jpg"" width = 50 >,这时输入框的内容变成了</p>

<p><img src = "https://farm1.staticflickr.com/686/21468673185_679ed4fcc0_z.jpg" width = 300px></p>

<p>并且在<code>tian</code>与<code>a</code>之间多出了一个空格。</p>

<p>我们先来看看这几个方法执行顺序：</p>

<ul>
<li>首先触发的是 <code>- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text;</code> 这个方法。打印结果如下：</li>
</ul>


<p><img src = "https://farm1.staticflickr.com/654/21468672825_45945d13d6_z.jpg" width = 468px></p>

<p>此时<code>markedTextRange</code>表示从第三个字符开始，长度为9所表示的区域（包括中间的空格）。</p>

<p>如果方法返回YES，表示<code>text</code>所表示的文本将会替代指定位置，即<code>range</code>所表示的区域的文本。这里<code>range</code>的<code>length=0</code>，表示这个<code>range</code>是光标插入的位置。这里打印出<code>text</code>的值，却是 <img style = "border:none"  src =" https://farm1.staticflickr.com/675/21477271371_0e05ce20f8_t.jpg" width = 12 >。猜测这里应该会在底层有一套处理逻辑，包括字符转换、联想等。因为我们看到的并不是这个奇怪的字符啊，而是在输入框看到了<code>a</code>。</p>

<ul>
<li>然后被触发的是 <code>- (void)textViewDidChangeSelection:(UITextView *)textView;</code> 这个方法.</li>
</ul>


<p><img src = "https://farm1.staticflickr.com/746/21442460826_d74163b3f5_o.png" width = 486></p>

<p>这时候<code>a</code>已经被追加到文本框中了，<code>textView.text</code>以及<code>textView.markedTextRange</code>都已经发生了变化。这个方法会被调用，主要也是因为<code>textView.markedTextRange</code>发生了变化吧。</p>

<p>注意，这是<code>a</code>跟前面的字符之间还没有出现空格，也就是说 这里只是简单的把一个字符放进了<code>markedTextRange</code>中。</p>

<ul>
<li>紧接着，<code>- (void)textViewDidChange:(UITextView *)textView;</code>
这个方法被调用</li>
</ul>


<p><img src = "https://farm1.staticflickr.com/746/21442460826_d74163b3f5_o.png" width = 486></p>

<p>这个方法里打印结果与前一个方法一样，是因为<code>textView.text</code>改变了所以被调用。</p>

<p>以为到这里结束了？然而，并！没！有！</p>

<p>在上面那个方法执行完了之后，底层应该又去默默地做了一些事情，比如，它觉得"tiana"这一坨好像并不
能组成一个中文字或词组，所以应该把他们分开？结果，它真的这么做了。</p>

<p>这时候，<code>- (void)textViewDidChangeSelection:(UITextView *)textView;</code>这个方法被调用了。</p>

<p>来看看发生了什么？</p>

<p><img src = "https://farm1.staticflickr.com/716/20845975984_2418dd4a05_o.png" width = 476></p>

<p>一个空格出现了！</p>

<p><code>textView.text</code>以及<code>textView.markedTextRange</code>都发生了变化，所以不出意外，接下来还会调用<code>- (void)textViewDidChange:(UITextView *)textView</code>,这里不再写了。</p>

<p>然后我们再看点别的。</p>

<p>假设我现在已经输入了这一段</p>

<p><img src = "https://farm6.staticflickr.com/5760/21280849488_7dbbfdcd13_o.png" width = 407></p>

<p>当选择<code>我是</code>后，这几个方法又是怎么调用的呢？</p>

<p>这次因为没有键入新的内容，所以<code>- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text;</code> 不会被调用。</p>

<p>先被调用的是<code>- (void)textViewDidChangeSelection:(UITextView *)textView；</code>方法：</p>

<p><img src = "https://farm6.staticflickr.com/5830/21468671185_c92fde6005_o.png" width = 472></p>

<p>这个方法中，<code>markedTextRange</code>已经被更改了，<code>textView.text = “我是ddmgwgmmgddwgpgjamg”</code>, 所以这个方法之后会调用<code>- (void)textViewDidChange:(UITextView *)textView；</code>这个方法，打印内容与这里一样，不赘述。</p>

<p>等等，为什么<code>textView.text</code>的值是<code>我是ddmgwgmmgddwgpgjamg</code>而不是<code>我是fengzhongdeyipilang"</code>?! 而且空格也不见了?! 咕~~(╯﹏╰)b，这里输入法已经将之前所有预测的字符全部改成了按键里的第一个字母了，并去掉了空格，也就是这里去掉了所有它自己推测的部分。因为在用户确认了部分文字后，它要对剩下的字符重新预测，因此，先要让所有输入都回到初始状态，然后对剩下的未确定的部分重新推算并在合适的位置加入空格。这样又会导致这两个方法再被调用一遍。</p>

<p><code>- (void)textViewDidChangeSelection:(UITextView *)textView</code>这个方法第二次被调用后，打印内容：</p>

<p><img src = "https://farm1.staticflickr.com/770/21477270021_6dd106ba62_o.png" width = 474></p>

<p>看，空格又回来了！但是，慢着，哪里不对？！输入法不仅加回了空格，还改变了文本框中显示的字符。因为这些字符是输入法推测出来的，所以每次输入一个字符、删除一个字符，输入法会根据当前剩下的所有未确定字符实时推测可能的组合情况，并加入空格。记住这一点很重要，因为我曾将尝试在<code>markedTextRange</code>不为空时去截断<code>textView.text</code>的内容（有个小需求是要检测特定字符，不让其显示到文本框），然后我发现所有一切都变得一团糟。比方说，当你获取到<code>textView.text</code>的值，并截取一段，然后重新设置<code>textView.text</code>之后，你会发现<code>markedTextRanged</code>变为nil，这时候还必须重新设置<code>markedTextRange</code>的值，否则你将会遇到一些奇奇怪怪的现象.</p>

<p>所以最终，我的方案是，只有在<code>markedTextRange==nil</code>时，才会对输入文本做检测，例如字数限制，字符检测，这种情况下再截断就不会有问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式-抽象工厂]]></title>
    <link href="http://lijunwu.github.io/blog/2015/01/24/she-ji-mo-shi-chou-xiang-gong-han/"/>
    <updated>2015-01-24T19:15:28+08:00</updated>
    <id>http://lijunwu.github.io/blog/2015/01/24/she-ji-mo-shi-chou-xiang-gong-han</id>
    <content type="html"><![CDATA[<h2>什么是抽象工厂</h2>

<p style="color:#666666;font-weight:bold;font-size:18px;line-height: 130%;text-indent:20pt">
提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体的类。它涉及多个类型的对象的创建，一系列相关类的好的模式，应该作为一种抽象，不为客户所见。抽象工厂模式可以提供这种抽象，从而不暴露创建过程中任何不必要的细节或所创建的对象的确切类型。
</p>


<div style="text-align:center">
<img src = "http://lijunwu.github.io/images/抽象工厂类图.png" style = "border:1px dashed #930f83;align:center"/>
</div>


<p><p style = "text-indent:20pt;">对于用户来说，他只知道AbstractFactory和AbstractProducts.至于这些工厂和产品的具体的结构和实现细节对用户来说都像一个放在工厂类里面的黑盒一样。每种产品甚至都不知道是哪个类负责创建他们。只有ConcreteFactory知道如何创建产品以及创建什么样的产品给用户。</p>

<h2>抽象工厂VS.工厂方法</h2>

<p><p style = "text-indent:20pt;">抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。</p>

<p><p style = "text-indent:20pt;">在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。我们依然拿生产汽车的例子来说明他们之间的区别。
<div style="text-align:center">
<img src = "http://lijunwu.github.io/images/抽象工厂VS.工厂方法.png" style = "border:1px dashed #930f83;align:center"/>
</div></p>

<h2>使用抽象工厂的效果</h2>

<p><ol>
<li> 它分离了具体的类</li>
一个工厂封装了创建产品对象的责任和过程，它将客户与类的实现分离。客户通过抽象接口操作实例。产品的类名也在具体工厂的实现中被分离，他们不出现在客户代码中。
<li>易于交换产品系列</li>
改变具体的工厂即可以使用不同的产品配置，因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。
<li>有利于产品一致性</li>
当一个系列中的产品被设计成一起工作时，一个应用一次只能使用同一个系列中的对象。
<li>难以支持新种类的产品</li>
抽象工厂接口确定了可以被创建的产品集合。要支持新种类的产品，就要扩展该工厂接口，这将涉及到AbstractFactory类及其所有子类的改变。
</ol></p>

<h2>抽象工厂的实现</h2>

<h3>可能会用到的一些有用的技术</h3>

<p><ol>
<li>将工厂作为单例</li>
一个应用中一般每个产品系列只需要一个ConcreteFactory的实例，因为工厂通常最好实现为一个Singleton。
<li>创建产品</li>
抽象工厂仅声明一个创建产品的接口，正在创建产品的是由ConcreteCreator子类实现的。最通常的一个方法是为每个产品定义一个工厂方法（工厂方法）,一个具体的工厂将为每个产品重新定义该工厂方法以指定产品。虽然这样的实现很简单，但它却要求每个产品系列都要有一个新的具体的工厂子类，即使这些产品系列的差别很小。
如果有多个可能的产品系列，具体工厂也可以使用Prototype模式来实现。具体工厂使用产品系列中每一个产品的原型实例来初始化。且它通过复制它的原型来创建新的产品。在基于原型的方法中，使得不是每个新的产品系列都需要一个新的具体工厂类。
<li>定义可扩展的工厂</li>
抽象工厂通常为每一种它可以生产的产品定义一个操作。产品的种类被编码在操作行构中。增加一种新的产品要求改变抽象工厂的接口以及所有与它相关的类。一个更加灵活但不太安全的设计是给创建对象的操作增加一个参数。这个参数可以标识这个被创建的产品的种类。它可以是一个类标识符，一个整数、一个字符串等。
</ol></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式-工厂方法]]></title>
    <link href="http://lijunwu.github.io/blog/2015/01/06/she-ji-mo-shi-gong-han-fang-fa/"/>
    <updated>2015-01-06T13:37:53+08:00</updated>
    <id>http://lijunwu.github.io/blog/2015/01/06/she-ji-mo-shi-gong-han-fang-fa</id>
    <content type="html"><![CDATA[<h2>什么是工厂方法</h2>

<p style="color:#666666;font-weight:bold;font-size:18px;line-height: 130%;text-indent:20pt">定义创建对象的接口，让子类决定实例化哪一个对象。工厂方法使得一个类的初始化延迟到其子类。工厂方法也被称为虚构造器。</p>


<div style="text-align:center">
<img src = "http://lijunwu.github.io/images/工厂方法类图.png" style = "border:1px dashed #930f83;align:center"/>
</div>


<p><p style = "text-indent:20pt;">抽象的Product定义了工厂方法创建的对象接口。ConcreteProduct实现了Product定义的接口。Creator定义了一个工厂方法，这个方法会返回一个Product对象，当然也可以为这个工厂方法提供一个默认的实现，返回一个默认的ConcreteProduct对象。Creator的其他方法可以调用这个工厂方法创建Product对象。ConcreteCreator是Creator的子类，它重载了工厂方法，并返回一个ConcreteProduct的实例。</p>

<h2>何时使用工厂方法</h2>

<p><p>当遇到以下情形时，可以考虑使用工厂模式
<ol>
<li>编译时无法准确预期想要创建的对象的类；
<li>类想让其子类决定在运行时创建什么；
<li>类有若干辅助类为其子类，而你想将返回哪个类这一信息局部化
</ol></p>

<h4>Cocoa中的例子</h4>

<p><p style = "text-indent:20pt;">Cocoa中使用这一架构的例子有NSNumber。尽管可以使用常见的alloc init两步法创建NSNumber的实例，但这基本上没做什么，除非你使用预先定义的类工厂方法来创建一个有意义的实例。例如，
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="bp">NSNumber</span> <span class="nl">numberWithBool</span><span class="p">:</span><span class="nb">YES</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>这个方法会得到一个NSCFBoolean的实例，这个实例包含传给类工厂方法的布尔值。</p>

<h2>使用工厂方法的效果</h2>

<p><p style="text-indent:20pt">工厂方法不再将与特定应用有关的类绑定到你的代码中，代码仅处理Product接口；因此它可以与用户定义的任何ConcreteProduct类一起使用。
<p style="text-indent:20pt">工厂方法的一个潜在缺点在于用户仅仅为了创建一个特定的ConcreteProduct对象，就不得不创建Creator的子类。当创建Creator子类不必需时，客户现在必然要处理类演化的其他方面；但是当客户无论如何必须创建Creator的子类时，创建子类也是可行的。</p>

<h4>下面是Factory Method模式的另外两种效果</h4>

<p><ol>
<li>为子类提供挂钩（hook）</li>
用工厂方法在一个类的内部创建对象通常比直接创建对象更灵活。Factory Method给子类一个挂钩以提供对象的扩展版本。
Creator可以定义工厂方法的合理的缺省实现。
<li>连接平行的类层次</li>
当一个类将它的职责委托给一个独立的类的时候，就产生了平行类层次。
工厂方法将哪些类应一同工作的信息局部化了。
</ol></p>

<h2>工厂方法的实现</h2>

<p><p style = "text-indent:20pt;">当应用Factory Method模式时，应考虑一下问题
<ol>
    <li>主要有两种不同的情况
        <ul>
            <li>Creator是一个抽象类，并且不提供它所声明的工厂方法的实现。这种情况需要子类来定义实现。它避免了不得不实例化不可预见类的问题
            <li>Creator是一个具体的类，而且为工厂方法提供一个缺省的实现。它所遵循的准则是：用一个独立的操作创建对象，这样子类才能重新定义他们的创建方式。
        </ul>
    </li>
    <li>参数化工厂方法</li>
    工厂方法采用一个标识要背创建的对象种类的参数。
</ol></p>

<h2>典型应用[来自网络]</h2>

<p><p style = "text-indent:20pt;">要说明工厂模式的优点，可能没有比组装汽车更合适的例子了。场景是这样的：汽车由发动机、轮、底盘组成，现在需要组装一辆车交给调用者。假如不使用工厂模式，代码如下：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">Engine</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">getEngine</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Engine</span> <span class="o"><em></span><span class="n">engine</span> <span class="o">=</span> <span class="p">[</span><span class="n">Engine</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;这是汽车的发动机&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">engine</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Underpan</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">getUnderpan</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Underpan</span> <span class="o"></em></span><span class="n">underpan</span> <span class="o">=</span> <span class="p">[</span><span class="n">Underpan</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;这是汽车的底盘&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">underpan</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Wheel</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">getWheel</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Wheel</span> <span class="err">\</span><span class="o"><em></span><span class="n">wheel</span> <span class="o">=</span> <span class="p">[</span><span class="n">Wheel</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;这是汽车的轮胎&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">wheel</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Car</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">makeCarWithEngine:</span><span class="p">(</span><span class="n">Engine</span> <span class="o"></em></span><span class="p">)</span><span class="nv">engine</span> <span class="nf">underpan:</span><span class="p">(</span><span class="n">Underpan</span> <span class="o"><em></span><span class="p">)</span><span class="nv">underpan</span> <span class="nf">wheel:</span><span class="p">(</span><span class="n">Wheel</span> <span class="o"></em></span><span class="p">)</span><span class="nv">wheel</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Car</span> <span class="o"><em></span><span class="n">car</span> <span class="o">=</span> <span class="p">[</span><span class="n">Car</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">car</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Client</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">Car</span> <span class="o"></em></span><span class="p">)</span><span class="nf">mainMethod</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Engine</span> <span class="o"><em></span><span class="n">engine</span> <span class="o">=</span> <span class="p">[</span><span class="n">Engine</span> <span class="n">getEngine</span><span class="p">];</span>
</span><span class='line'>    <span class="n">Underpan</span> <span class="o"></em></span><span class="n">underpan</span> <span class="o">=</span> <span class="p">[</span><span class="n">Underpan</span> <span class="n">getUnderpan</span><span class="p">];</span>
</span><span class='line'>    <span class="n">Wheel</span> <span class="o"><em></span><span class="n">wheel</span> <span class="o">=</span> <span class="p">[</span><span class="n">Wheel</span> <span class="n">getWheel</span><span class="p">];</span>
</span><span class='line'>    <span class="n">Car</span> <span class="o"></em></span><span class="n">car</span> <span class="o">=</span> <span class="p">[</span><span class="n">Car</span> <span class="nl">makeCarWithEngine</span><span class="p">:</span><span class="n">engine</span> <span class="nl">underpan</span><span class="p">:</span><span class="n">underpan</span> <span class="nl">wheel</span><span class="p">:</span><span class="n">wheel</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">car</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p><p style="text-indent:20pt">可以看到，调用者为了组装汽车还需要另外实例化发动机、底盘和轮胎，而这些汽车的组件是与调用者无关的，严重违反了迪米特法则，耦合度太高。并且非常不利于扩展。另外，本例中发动机、底盘和轮胎还是比较具体的，在实际应用中，可能这些产品的组件也都是抽象的，调用者根本不知道怎样组装产品。假如使用工厂方法的话，整个架构就显得清晰了许多。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">Factory</span> : <span class="bp">NSObject</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="n">Car</span> <span class="o"><em></span><span class="p">)</span><span class="nf">makeCar</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Factory</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="n">Car</span> <span class="o"></em></span><span class="p">)</span><span class="nf">makeCar</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Engine</span> <span class="o"><em></span><span class="n">engine</span> <span class="o">=</span> <span class="p">[</span><span class="n">Engine</span> <span class="n">getEngine</span><span class="p">];</span>
</span><span class='line'>    <span class="n">Underpan</span> <span class="o"></em></span><span class="n">underpan</span> <span class="o">=</span> <span class="p">[</span><span class="n">Underpan</span> <span class="n">getUnderpan</span><span class="p">];</span>
</span><span class='line'>    <span class="n">Wheel</span> <span class="o"><em></span><span class="n">wheel</span> <span class="o">=</span> <span class="p">[</span><span class="n">Wheel</span> <span class="n">getWheel</span><span class="p">];</span>
</span><span class='line'>    <span class="n">Car</span> <span class="o"></em></span><span class="n">car</span> <span class="o">=</span> <span class="p">[</span><span class="n">Car</span> <span class="nl">makeCarWithEngine</span><span class="p">:</span><span class="n">engine</span> <span class="nl">underpan</span><span class="p">:</span><span class="n">underpan</span> <span class="nl">wheel</span><span class="p">:</span><span class="n">wheel</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">car</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Client</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">Car</span> <span class="o"><em></span><span class="p">)</span><span class="nf">mainMethod</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Car</span> <span class="o"></em></span><span class="n">car</span> <span class="o">=</span> <span class="p">[</span><span class="n">Factory</span> <span class="n">makeCar</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">car</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p><p style="text-indent:20pt">  使用工厂方法后，调用端的耦合度大大降低了。并且对于工厂来说，是可以扩展的，以后如果想组装其他的汽车，只需要再增加一个工厂类的实现就可以。无论是灵活性还是稳定性都得到了极大的提高。</p>
]]></content>
  </entry>
  
</feed>
